const char *boot_scm=";; [ Copyright (C) 2011 Dave Griffiths : GPLv2 see LICENCE ]\n"
"\n"
"(define frame-thunk '())\n"
"(define flx_time 0)\n"
"\n"
"(define-macro (every-frame . args)\n"
"  `(begin (set! frame-thunk (lambda () ,@args))))\n"
"\n"
"(define (frame-hook)\n"
"  (set! flx_time (+ flx_time 1))\n"
"  (if (not (null? frame-thunk))\n"
"      (frame-thunk)))\n"
"\n"
"(define triangles 0)\n"
"(define triangle-strip 1)\n"
"\n"
"(define (hint-none) (hint 0)) \n"
"(define (hint-unlit) (hint 6)) \n"
"\n"
"(define _mouse-x 0)\n"
"(define _mouse-y 0)\n"
"\n"
"(define (input-mouse x y)\n"
"  (set! _mouse-x x)\n"
"  (set! _mouse-y y))\n"
"\n"
"(define (mouse-x) _mouse-x)\n"
"(define (mouse-y) _mouse-y)\n"
"\n"
"(define (time) flx_time)\n"
"\n"
"(define-macro (with-state . args) \n"
"  `(begin (push) (let ((r (begin ,@args))) (pop) r)))\n"
"\n"
"(define-macro (with-primitive . args) \n"
"  (let ((id (car args)) (body (cdr args)))\n"
"    `(begin (grab ,id) (let ((r (begin ,@body))) (ungrab) r))))\n"
"\n"
"(define (build-list fn n)\n"
"  (define (_ fn n l)\n"
"    (cond ((zero? n) l)  \n"
"          (else \n"
"           (_ fn (- n 1) (cons (fn n) l)))))\n"
"  (_ fn n '()))   \n"
"\n"
"(define (square x) \n"
"  (* x x))\n"
"\n"
"(define (vx v) (vector-ref v 0))\n"
"(define (vy v) (vector-ref v 1))\n"
"(define (vz v) (vector-ref v 2))\n"
"\n"
"(define (vadd a b)\n"
"  (vector (+ (vx a) (vx b)) \n"
"          (+ (vy a) (vy b))\n"
"          (+ (vz a) (vz b)))) \n"
"\n"
"(define (vmag v)\n"
"  (sqrt (+ (square (vx v))\n"
"           (square (vy v))\n"
"           (square (vy v)))))\n"
"         \n"
"(define (vsub a b)\n"
"  (vector (+ (vx a) (vx b)) \n"
"          (+ (vy a) (vy b))\n"
"          (+ (vz a) (vz b)))) \n"
"\n"
"(define (vmul v a)\n"
"  (vector (* (vx v) a) (* (vy v) a) (* (vz v) a))) \n"
"\n"
"(define (vdiv v a)\n"
"  (vector (/ (vx v) a) (/ (vy v) a) (/ (vz v) a))) \n"
"\n"
"(define (vdist a b)\n"
"  (vmag (vsub a b)))\n"
"\n"
"(define (vlerp v1 v2 t)\n"
"	(vadd v1 (vmul (vsub v2 v1) t)))\n"
"\n"
"(define (pdata-map! . args)\n"
"  (let ((proc (car args))\n"
"        (pdata-write-name (cadr args))\n"
"        (pdata-read-names (cddr args)))\n"
"     (letrec\n"
"         ((loop (lambda (n total)\n"
"                  (cond ((not (> n total))\n"
"                         (pdata-set! \n"
"                          pdata-write-name n\n"
"                          (apply\n"
"                           proc \n"
"                           (cons\n"
"                            (pdata-ref pdata-write-name n)\n"
"                            (map\n"
"                             (lambda (read)\n"
"                               (pdata-ref read n))\n"
"                             pdata-read-names))))\n"
"                         (loop (+ n 1) total))))))\n"
"       (loop 0 (- (pdata-size) 1)))))\n"
"\n"
"\n"
"(define (pdata-copy a b)\n"
"  (pdata-add b)\n"
"  (pdata-map! (lambda (b a) a) b a))\n"
"\n"
"(define (vtransform v m)\n"
"  (vector\n"
"    	(+ (* (vx v) (vector-ref m 0)) \n"
"           (* (vy v) (vector-ref m 4))\n"
"           (* (vz v) (vector-ref m 8))\n"
"           (vector-ref m 12))\n"
"    	(+ (* (vx v) (vector-ref m 1))\n"
"           (* (vy v) (vector-ref m 5))\n"
"           (* (vz v) (vector-ref m 9))\n"
"           (vector-ref m 13))\n"
"    	(+ (* (vx v) (vector-ref m 2)) \n"
"           (* (vy v) (vector-ref m 6))\n"
"           (* (vz v) (vector-ref m 10))\n"
"           (vector-ref m 14))))\n"
"\n"
"\n"
"(define random-maker\n"
"  (let* ((multiplier 48271)\n"
"         (modulus 2147483647)\n"
"         (apply-congruence\n"
"          (lambda (current-seed)\n"
"            (let ((candidate (modulo (* current-seed multiplier)\n"
"                                     modulus)))\n"
"              (if (zero? candidate)\n"
"                  modulus\n"
"                  candidate))))\n"
"         (coerce\n"
"          (lambda (proposed-seed)\n"
"            (if (integer? proposed-seed)\n"
"                (- modulus (modulo proposed-seed modulus))\n"
"                19860617))))  ;; an arbitrarily chosen birthday\n"
"  (lambda (initial-seed)\n"
"    (let ((seed (coerce initial-seed)))\n"
"      (lambda args\n"
"        (cond ((null? args)\n"
"               (set! seed (apply-congruence seed))\n"
"               (/ (- modulus seed) modulus))\n"
"              ((null? (cdr args))\n"
"               (let* ((proposed-top\n"
"                       (ceiling (abs (car args))))\n"
"                      (exact-top\n"
"                       (if (inexact? proposed-top)\n"
"                           (inexact->exact proposed-top)\n"
"                           proposed-top))\n"
"                      (top\n"
"                       (if (zero? exact-top)\n"
"                           1\n"
"                           exact-top)))\n"
"                 (set! seed (apply-congruence seed))\n"
"                 (inexact->exact (floor (* top (/ seed modulus))))))\n"
"              ((eq? (cadr args) 'reset)\n"
"               (set! seed (coerce (car args))))\n"
"              (else\n"
"               (display \"random: unrecognized message\")\n"
"               (newline))))))))\n"
"\n"
"(define random\n"
"  (random-maker 19781116))  ;; another arbitrarily chosen birthday\n"
"\n"
"(define rndf random)\n"
"\n"
"(define (rndvec) (vector (rndf) (rndf) (rndf)))\n"
"   \n"
"\n"
"(define (get-line-from-mouse)\n"
"  (let* ((ndcpos (vector (* (- (/ (mouse-x) (vx (get-screen-size))) 0.5) 2)\n"
"                         (* (- (- (/ (mouse-y) (vy (get-screen-size))) 0.5)) 1.5) -1))\n"
"         (scrpos2 (vtransform (vmul ndcpos -500) (get-camera-transform)))\n"
"         (scrpos (vtransform ndcpos (get-camera-transform))))\n"
"    (list scrpos scrpos2)))\n"
"\n"
"(define (get-point-from-mouse)\n"
"  (let* ((line (get-line-from-mouse))\n"
"         (mid (vlerp (car line) (cadr line) 0.5)))\n"
"    (vector (* (vx mid) (* -0.065 0.5))\n"
"            (* (vy mid) (* -0.1 0.5))\n"
"            0)))\n";
